<!DOCTYPE html>
<html>

<head>
  <title></title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.1.5/dist/jszip.min.js"></script>
</head>

<body>
  <h1 id="test">test</h1>
  <div id="app"></div>
  <input type="text" name="nameField" id="name">
  <button id="clearInput">X</button>
  <button id="download-button">Download</button>
  <p>Choosable syntax</p>
  <ul class="chips">
    <li onclick="addTextToInput('{{name}}')">name</li>
    <li onclick="addTextToInput('{{date}}')">date</li>
    <li onclick="addTextToInput('{{file}}')">file</li>
    <li onclick="addTextToInput('{{scaling}}')">scaling</li>
  </ul>
  <select name="dateFormat" id="dateFormat">
    <option value="date-01">YYMMDD</option>
    <option value="date-02">YYYY-MM-DD</option>
    <option value="date-03">DD-MM-YYYY</option>
    <option value="date-04">MM-DD-YYYY</option>
  </select>
  <input type="checkbox" id="exportFrameSize" name="exportFrameSize">
  <label for="exportFrameSize">export in frame size</label><br>
  <select name="fileFormat" id="fileFormat" onchange="showScaling(this.options[this.selectedIndex].value)">
    <option value="png">PNG</option>
    <option value="jpg">JPG</option>
    <option value="svg">SVG</option>
    <option value="pdf">PDF</option>
  </select>
  <select name="scaling" id="scaling">
    <option value="scaling-01">x1</option>
    <option value="scaling-02">x2</option>
    <option value="scaling-03">x3</option>
    <option value="scaling-04">x4</option>
  </select>
  <script>
    console.log('direct script tag inside the .ui.html')
    const downloadButton = document.getElementById('download-button');
    const dateFormatObj = document.getElementById('dateFormat');
    const fileFormatObj = document.getElementById('fileFormat');
    const scalingObj = document.getElementById('scaling');
    const exportFrameSize = document.getElementById('exportFrameSize');
    const input = document.getElementById('name');
    const clearInputButton = document.getElementById('clearInput');

    // this function adds syntax text to the input field
    const addTextToInput = (text) => {
      // this sub function adds the text to the cursor position.
      // used from https://stackoverflow.com/a/11077016
      function insertAtCursor(myField, myValue) {
        //IE support
        if (document.selection) {
          myField.focus();
          sel = document.selection.createRange();
          sel.text = myValue;
        }
        //MOZILLA and others
        else if (myField.selectionStart || myField.selectionStart == '0') {
          var startPos = myField.selectionStart;
          var endPos = myField.selectionEnd;
          myField.value = myField.value.substring(0, startPos)
            + myValue
            + myField.value.substring(endPos, myField.value.length);
        } else {
          myField.value += myValue;
        }
      }
      insertAtCursor(input, text)
      // input.value += text
    }

    // clear the name input field
    clearInputButton.addEventListener('click', () => {
      input.value = '';
    });

    downloadButton.addEventListener('click', () => {
      const dateFormat = dateFormatObj.selectedIndex;
      const fileFormat = fileFormatObj.selectedIndex;
      const scaling = scalingObj.selectedIndex + 1;
      const isExportFrameSizeChecked = exportFrameSize.checked;
      const pluginMessage = JSON.stringify({
        type: '01-collect-data',
        name: document.getElementById('name').value,
        dateFormat,
        fileFormat,
        scaling,
        isExportFrameSizeChecked
      })
      parent.postMessage({
        pluginMessage
      }, '*');
    });

    function byteDataToBlob(byteData) {
      return new Blob([new Uint8Array(byteData)], { type: 'image/png' });
    }

    // MULTIPLE FILE EXPORT AS ZIP
    const downloadZip = async (files) => {

      const zip = new JSZip();

      // each asset in the bundle will be added as seperated images to the zip
      files.forEach(file => {
        zip.file(`${file.name}.png`, byteDataToBlob(file.binaryData[0]), { base64: true });
      });

      // zip file will be generated here
      zip.generateAsync({ type: 'blob' })
        .then((content) => {
          const zipName = 'assets';

          // create and click a temporary link to download the Blob
          const blobURL = window.URL.createObjectURL(content);
          const link = document.createElement('a');
          link.className = 'button button--primary';
          link.href = blobURL;
          link.download = `${zipName}.zip`
          link.click()
          link.setAttribute('download', `${zipName}.zip`);

          // clean up the blobURL and link element
          window.URL.revokeObjectURL(blobURL);
          link.remove();
        });

    };

    // SINGLE FILE EXPORT
    const downloadSingleFile = (file) => {

      // the blob type is file specific
      let blob;
      if (file.format === 'PNG') {
        blob = new Blob(file.binaryData, { type: 'image/png' });
      } else if (file.format === 'JPG') {
        blob = new Blob(file.binaryData, { type: 'image/jpg' });
      } else if (file.format === 'SVG') {
        blob = new Blob(file.binaryData, { type: 'image/svg+xml' });
      } else if (file.format === 'PDF') {
        blob = new Blob(file.binaryData, { type: 'application/pdf' });
      } else {
        console.error('undefined or unknown file format')
      }

      // create and click a temporary link to download the Blob
      const blobURL = window.URL.createObjectURL(blob);
      const linkEl = document.createElement('a');
      linkEl.href = blobURL;
      linkEl.download = `${file.name}.${file.format}`;
      linkEl.click();
      linkEl.setAttribute('download', `${file.name}.${file.format}`);

      // clean up the blobURL and link element
      window.URL.revokeObjectURL(blobURL);
      linkEl.remove();
    }

    // General message receiver
    window.onmessage = (msg) => {
      const m = msg.data.pluginMessage;
      // get the bundled information, including image data + config information
      if (m.type === '02-export-bundle') {
        const exportBundle = m.exportBundle;
        // depending on if the user has selected one or multiple images, start a function that downloads a single image or a zip file
        exportBundle.length > 1 ? downloadZip(exportBundle) : downloadSingleFile(exportBundle[0]);
        // react if there is no selection
      } else if (m.type === 'selection-empty') {
        const isSelectionEmpty = m.isSelectionEmpty;
        if (isSelectionEmpty) {
          // downloadButton.style.opacity = 0.5;
          downloadButton.setAttribute('disabled', '');
        } else {
          // downloadButton.style.opacity = 1;
          downloadButton.removeAttribute('disabled', '');
        }
      }
    }

    // ====== REACTIVITY FUNCTIONS ======
    // Might be that some reactivity functions are living in window.onmessage();

    // enable / disable scaling option if not supported by the selected file format
    const showScaling = (e) => {
      if (e === 'png' || e === 'jpg') {
        scalingObj.style.opacity = 1;
        scalingObj.removeAttribute('disabled', '');
      } else {
        scalingObj.style.opacity = 0;
        scalingObj.setAttribute('disabled', '');
      }
    }
  </script>
</body>
<style>
  body {
    background-color: var(--bg);
    color: var(--text);
  }

  .figma-dark {
    --text: #e9e9e9;
    --bg: #242424;
  }

  .figma-light {
    --text: #242424;
    --bg: #e9e9e9;
  }

  .chips {
    list-style: none;
  }

  .chips {
    li {
      display: inline-block;
      width: 60px;
      height: 24px;
      text-align: center;
      border-radius: 18px;
      background-color: hsl(0deg 0% 0% / 20%);

      &:hover {
        background-color: hsl(0deg 0% 0% / 40%);
      }
    }
  }
</style>
</html>